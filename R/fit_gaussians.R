#' Fit a mixture of Gaussians to a chromatogram curve
#'
#' Fit mixtures of one or more Gaussians to the curve formed by a chromatogram
#' profile, using nonlinear least-squares. 
#' 
#' @param chromatogram a numeric vector corresponding to the chromatogram trace
#' @param n_gaussians the number of Gaussians to fit
#' @param max_iterations the number of times to try fitting the curve with
#' different initial conditions; defaults to 5
#' @param min_R_squared the minimum R-squared value to accept when fitting the
#' curve with different initial conditions; defaults to 0.5
#' @param method the method used to select the initial conditions for
#' nonlinear least squares optimization (one of "guess" or "random"); 
#' see \code{\link{make_initial_conditions}} for details
#' @param filter_gaussians_center true or false: filter Gaussians whose centres
#' fall outside the bounds of the chromatogram 
#' @param filter_gaussians_height Gaussians whose heights are below this 
#' fraction of the chromatogram height will be filtered. Setting this value to
#' zero disables height-based filtering of fit Gaussians
#'
#' @return a list with six entries: the number of Gaussians used to fit
#' the curve; the R^2 of the fit; the number of iterations used to 
#' fit the curve with different initial conditions; the coefficients of the 
#' fit model; the fit curve created by applying the \code{predict} function to
#' the fit; and the fit object generated by \code{nls}.
#' 
#' @export
fit_gaussians <- function(chromatogram, n_gaussians,
                          max_iterations = 5, min_R_squared = 0.5,
                          method = c("guess", "random"),
                          filter_gaussians_center = T,
                          filter_gaussians_height = 0.15) {
  indices <- seq_len(length(chromatogram))
  iter <- 0
  bestR2 <- 0
  bestFit <- NULL
  bestCoefs <- NULL
  while (iter < max_iterations & bestR2 < min_R_squared) {
    # increment iteration counter
    iter <- iter + 1
    # make initial conditions
    initial_conditions <- make_initial_conditions(
      chromatogram, n_gaussians, method = "guess", seed = iter)
    A <- initial_conditions$A
    mu <- initial_conditions$mu
    sigma <- initial_conditions$sigma
    
    # fit the model
    p_model <- function(x, A, mu, sigma) {
      rowSums(sapply(seq_len(n_gaussians), 
                     function(i) A[i] * exp(-((x - mu[i])/sigma[i])^2)))
    }
    fit <- stats::nls(chromatogram ~ p_model(indices, A, mu, sigma), 
               start = list(A = A, mu = mu, sigma = sigma), 
               trace = F,  
               control = list(warnOnly = T, minFactor = 1/2048))
    coef <- coef(fit)
    
    # (optional): remove Gaussians outside bounds of chromatogram
    if (filter_gaussians_center) {
      means <- coef[startsWith(names(coef), "mu")]
      filter <- which(means < 0 | means > length(chromatogram))
      for (idx in filter) {
        coef <- coef[!endsWith(names(coef), as.character(idx))]
      }
    }
    
    # (optional): remove Gaussians less than 15% of height
    if (filter_gaussians_height > 0) {
      minHeight <- max(chromatogram) * filter_gaussians_height
      heights <- coef[startsWith(names(coef), "A")]
      filter <- which(heights < minHeight)
      for (idx in filter) {
        coef <- coef[!endsWith(names(coef), as.character(idx))]
      }
    }
    
    # if coefficients are empty, try again
    if (isEmpty(coef))
      next
    
    # calculate R^2
    curveFit <- fit_curve(coef, indices)
    R2 <- cor(chromatogram, curveFit)^2
    # replace best fit with this model?
    if (R2 > bestR2) {
      bestR2 <- R2
      bestFit <- fit
      bestCoefs <- coef
    }
  }
  results <- list(n_gaussians = n_gaussians, R2 = bestR2, iterations = iter,
                  coefs = bestCoefs, curveFit = fit_curve(bestCoefs, indices),
                  fit = bestFit)
  return(results)
}
